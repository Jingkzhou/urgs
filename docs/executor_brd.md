# 统一调度系统执行器 (Executor) 业务需求文档

## 1. 引言
### 1.1 背景
统一调度系统旨在解决企业内部复杂的数据处理与任务调度需求。执行器（Executor）作为系统的核心组件，负责接收调度指令、执行具体业务逻辑、管理任务生命周期以及处理任务间的依赖关系。

### 1.2 目标
构建一个高可用、可扩展、支持多种任务类型的分布式执行器，确保任务能够准时、准确、高效地执行。

## 2. 核心功能需求

### 2.1 任务获取与调度
- **轮询机制 (Polling)**: 执行器需定期（如每3秒）从数据库或队列中拉取状态为 `WAITING` 的任务实例。
- **并发控制**:
    - 支持配置最大并发执行数，防止资源过载。
    - **分布式锁**: 在多节点部署时，必须确保同一任务实例同一时间只能被一个执行器节点获取（通过数据库行锁或Redis锁实现）。
- **负载均衡**: 多个执行器节点应能自动分担负载，避免单点压力过大。

### 2.2 任务执行能力
执行器需支持多种类型的任务插件，具备良好的扩展性：
- **Shell 任务**: 在服务器本地执行 Shell 脚本。
- **Python 任务**: 支持执行 Python 脚本，支持指定 Python 环境。
- **SQL/Procedure 任务**: 支持连接多种数据库（MySQL, Oracle, Hive等）执行 SQL 语句或存储过程。
- **DataX 任务**: 集成 DataX 引擎，执行数据同步作业。
- **HTTP 任务**: 发起 HTTP 请求（GET/POST），支持自定义 Header 和 Body，用于触发外部系统。
- **依赖任务 (Dependent)**: 虚拟任务，用于检查其他工作流或任务的执行状态。

### 2.3 状态与生命周期管理
- **状态流转**: 严格管理任务实例状态：`WAITING` -> `RUNNING` -> `SUCCESS` / `FAILURE`。
- **超时控制**: 支持设置任务最大运行时间，超时自动终止并标记失败。
- **强制停止**: 支持接收用户指令，强制终止正在运行的任务（如 `kill` 进程）。
- **重试机制**: 任务失败时，根据配置的重试次数和间隔自动重试。

### 2.4 依赖管理
- **上游依赖检查**: 任务执行前，必须校验其所有上游依赖任务在**当前数据日期**（或指定规则下）是否已成功完成。
- **下游触发**: 任务执行成功后，自动触发下游依赖任务的状态流转（如将下游从 `PENDING` 更新为 `WAITING`）。
- **跨周期/跨流依赖**: 支持跨工作流、跨数据日期的复杂依赖配置。

### 2.5 日志与监控
- **实时日志**: 捕获任务执行的标准输出（stdout）和错误输出（stderr），保存至日志文件或数据库，支持前端实时查看。
- **告警通知**: 任务失败、超时或长时间等待时，发送告警（邮件、钉钉、企业微信）。
- **心跳监测**: 执行器需定期上报心跳，以便调度中心感知节点存活状态。

## 3. 非功能需求

### 3.1 高可用性 (HA)
- 执行器应支持集群部署。
- 当某节点宕机时，其正在执行的任务应能被检测到（如通过心跳超时），并由其他节点接管重试。

### 3.2 扩展性
- 采用插件化架构设计 `TaskHandler`，新增任务类型时无需修改核心调度逻辑，只需实现标准接口。

### 3.3 性能
- **低延迟**: 任务从就绪到开始执行的延迟应在秒级。
- **高吞吐**: 单节点应能支撑数百并发任务（取决于具体任务类型和机器配置）。

### 3.4 安全性
- **权限隔离**: 不同任务应尽可能以独立用户或沙箱环境执行，防止恶意脚本破坏系统。
- **敏感数据保护**: 数据库密码、API Key 等敏感信息在日志和数据库中应加密存储或脱敏展示。

## 4. 架构简述
- **通信模式**: 采用“拉模式”（Pull）为主，执行器主动从 DB/Queue 获取任务，避免调度中心推送压力。
- **数据一致性**: 依赖数据库事务和乐观锁/悲观锁机制保证任务状态流转的原子性。

## 5. 附录
- **数据模型**: `sys_task_instance`, `sys_task_dependency`
- **关键类**: `TaskExecutor`, `TaskHandlerFactory`, `TaskGeneratorJob`
